`repeated_inheritance.cpp`是重复继承的例子，其中没有用虚函数。由于使用了gcc的特性，需要用g++编译。`__attribute__((packed))`用于关闭对齐用的padding，方便分析内存布局。程序中B和C类都继承了A类，D类继承和B和C两个类。从程序输出的地址偏移可以看出，D类大小为5字节，这5字节分别保存了：a1、b、a2、c、d，其中a1和a2是两份A类的数据成员。这说明在种重复继承的情形下被重复继承的类有多个实例。

把这个程序做一些改动，改为虚继承（在B和C继承A的地方加virtual关键字），得到`virtual_inheritance.cpp`。程序输出的结果有了变化。根据输出的地址偏移可以分析内存布局。D类大小20字节。`d.B::a`和`d.C::a`地址相同，说明A类只有一个。而且通过`d.a`访问a没有报错（之前一种情况会报错，因为不知道你指的是哪个a）。内存布局：一个指针、b、一个指针、c、d、a。这说明在种重复继承的情形下被重复继承的类有唯一的实例。

从函数的地址可以看出， 只要是同一个函数，地址就是相同的。不会因为继承而为子类生成一个新的函数。

对vtable分析了很久，在虚继承的情况下一直没有搞清楚数据的布局。但是通过阅读很多文章，弄懂了其中的大致原理。这里就不深入分析vtable了。一篇不错的文章：http://www.drdobbs.com/cpp/multiple-inheritance-considered-useful/184402074

总结：C++中继承具有相同父类的两个类就会出现重复继承，公共父类具有两份数据，不能直接通过名字操作公共父类的成员，需要显示指明，例如`d.B::a`和`d.C::a`。B和C继承A时使用虚继承，就可以避免这种问题，公共父类只有一份，可以直接通过名字操作父类（因为此时没有歧义），但是公共父类不属于B或C，需要在D的构造函数指明如何初始化。

遇到的问题：

- 不知道如何输出函数的地址。使用[这个网页](http://stackoverflow.com/questions/3068144/print-address-of-virtual-member-function)的办法解决。
- 因为数据有对齐的padding，所以不方便分析数据布局，使用gcc的`__attribute__((packed))`关闭对齐。
- 程序输出的数据成员地址不直观，改为输出偏移量，并且数据成员都使用char类型。
- 当重复继承时，ABCD类中都定义变量a，如何从D类的对象直接访问A类的a（不用强制类型转换）？未解决，但不影响分析。
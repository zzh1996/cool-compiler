**3.1.5 简要说明`test.c`、`AST.svg`、`CFG.svg`和`ExplodedGraph.svg`之间的联系与区别**

`test.c`是程序的源代码。`AST.svg`由源代码生成，展示了整棵抽象语法树。`CFG.avg`是整个程序的流程图，箭头展示了不同代码块之间的跳转关系。`ExplodedGraph.svg`是分析器沿所有路径进行symbolic execution得到的状态，其中包含了每个状态详细的信息。

**3.2.1  Checker 对于程序的分析主要在 AST 上还是在 CFG 上进行？**

当然是CFG。

**3.2.2 Checker 在分析程序时需要记录程序状态，这些状态一般保存在哪里？**

checker保存的状态位于`GenericDataMap`

**3.2.3简要解释分析器在分析下面程序片段时的过程，在过程中产生了哪些symbolic values? 它们的关系是什么？**

`int x = 3`中会生成代表常量3的SVal，赋值过程中将其绑定到x的MemRegion。`y=4`同理。

`int *p = &x;`把x的地址生成一个SVal（而x不会，因为取地址没有lvalue到rvalue的转换）。把`&x`这个symbolic expression叫做`$0`，在赋值时将这个SVal与p的MemRegion绑定。

`int z = *(p + 1);`中，先把p转换为rvalue，生成一个SVal，代表p的当前值，这个symbol叫`$1`。然后也有一个SVal代表常数1。计算`p+1`时生成新的SVal，叫`$2`。解引用时又生成新的SVal，叫`$3`。最后将`*(p+1)`转换为rvalue，生成新的SVal，叫做`$4`，赋值将其当前值与z的MemRegion绑定。

**3.3.1 LLVM 大量使用了 C++11/14的智能指针，请简要描述几种智能指针的特点、使用场合，如有疑问也可以记录在报告中.**

unique_ptr：全局只有一份引用，不可复制，指针被析构时所指向对象即销毁，语义上代表所有权，适合只有一份引用的情况。

shared_ptr：全局可以有多个指针指向相同对象，使用引用计数管理内存，引用计数为0时销毁对象，适合被多者引用的情况。

weak_ptr：和shared_ptr类似，但不增加引用计数，语义上其指向对象随时可被销毁，适合没有"所属权"的情况或者会导致循环引用的情况。

**3.3.2 LLVM 不使用 C++ 的运行时类型推断（RTTI），理由是什么？LLVM 提供了怎样的机制来代替它？**

理由是减少代码和可执行文件的大小，同时也可以提高执行效率。LLVM提供了`isa<>`、`cast<>`、`dyn_cast<> `模板来实现RTTI。

**3.3.3 如果你想写一个函数，它的参数既可以是数组，也可以是std::vector，那么你可以声明该参数为什么类型？如果你希望同时接受 C 风格字符串和 std::string 呢？**

数组：`llvm::ArrayRef`，字符串：`llvm::StringRef`（`std::string`也可以，但效率不高）。

**3.3.4 你有时会在cpp文件中看到匿名命名空间的使用，这是出于什么考虑？**

匿名命名空间可以让里面的内容（尤其是class，因为变量和函数都可以用static）仅对当前翻译单元可见，可以避免名称冲突。

